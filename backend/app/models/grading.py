"""Grading-related models."""

from sqlalchemy import Column, String, DateTime, ForeignKey, Enum as SQLEnum, Boolean, Integer, Text, JSON, Float, Numeric
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import uuid
import enum

from ..database import Base


class GradingMode(enum.Enum):
    """Grading mode enumeration."""
    copilot = "copilot"
    agent = "agent"


class GradingStatus(enum.Enum):
    """Grading status enumeration."""
    pending = "pending"
    processing = "processing"
    completed = "completed"
    failed = "failed"
    requires_review = "requires_review"


class AnchorType(enum.Enum):
    """Anchor type enumeration."""
    span = "span"
    bbox = "bbox"
    slide_region = "slide_region"
    line_range = "line_range"


class GradingSession(Base):
    """Grading session model."""
    __tablename__ = "grading_sessions"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    submission_id = Column(String(36), ForeignKey("submissions.id"))
    rubric_id = Column(String(36), ForeignKey("rubrics.id"))
    mode = Column(SQLEnum(GradingMode))
    status = Column(SQLEnum(GradingStatus), default=GradingStatus.pending)
    overall_score = Column(Numeric(5, 2))
    ai_confidence = Column(Float)
    teacher_approved = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    submission = relationship("Submission", back_populates="grading_sessions")
    rubric = relationship("Rubric", back_populates="grading_sessions")
    evidence_anchors = relationship("EvidenceAnchor", back_populates="grading_session")
    ai_action_logs = relationship("AIActionLog", back_populates="session")

    def __repr__(self):
        return f"<GradingSession(id={self.id}, status='{self.status.value}')>"

    @property
    def is_completed(self):
        """Check if grading session is completed."""
        return self.status == GradingStatus.completed

    @property
    def is_processing(self):
        """Check if grading session is processing."""
        return self.status == GradingStatus.processing

    @property
    def needs_review(self):
        """Check if grading session needs review."""
        return self.status == GradingStatus.requires_review

    @property
    def has_failed(self):
        """Check if grading session failed."""
        return self.status == GradingStatus.failed

    @property
    def confidence_level(self):
        """Get AI confidence level as string."""
        if self.ai_confidence is None:
            return "unknown"
        elif self.ai_confidence >= 0.9:
            return "high"
        elif self.ai_confidence >= 0.7:
            return "medium"
        else:
            return "low"

    @property
    def evidence_count(self):
        """Get count of evidence anchors."""
        return len(self.evidence_anchors)

    def get_evidence_for_criterion(self, criterion_id: str):
        """Get evidence anchors for a specific criterion."""
        return [anchor for anchor in self.evidence_anchors if anchor.criterion_id == criterion_id]


class EvidenceAnchor(Base):
    """Evidence anchor model."""
    __tablename__ = "evidence_anchors"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    grading_session_id = Column(String(36), ForeignKey("grading_sessions.id"))
    criterion_id = Column(String(100))
    anchor_type = Column(SQLEnum(AnchorType))
    coordinates = Column(JSON, default={})
    evidence_text = Column(Text)
    rationale = Column(Text)
    confidence = Column(Float)
    created_by = Column(String(50), default="ai")
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    grading_session = relationship("GradingSession", back_populates="evidence_anchors")

    def __repr__(self):
        return f"<EvidenceAnchor(id={self.id}, criterion_id='{self.criterion_id}')>"

    @property
    def is_ai_generated(self):
        """Check if evidence was generated by AI."""
        return self.created_by == "ai"

    @property
    def is_teacher_generated(self):
        """Check if evidence was generated by teacher."""
        return self.created_by == "teacher"

    @property
    def confidence_level(self):
        """Get confidence level as string."""
        if self.confidence is None:
            return "unknown"
        elif self.confidence >= 0.9:
            return "high"
        elif self.confidence >= 0.7:
            return "medium"
        else:
            return "low"

    def get_coordinate_value(self, key: str, default=None):
        """Get a specific coordinate value."""
        if not self.coordinates:
            return default
        return self.coordinates.get(key, default)


class AIActionLog(Base):
    """AI action log model."""
    __tablename__ = "ai_action_log"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    session_id = Column(String(36), ForeignKey("grading_sessions.id"))
    action_type = Column(String(100))
    model_version = Column(String(100))
    prompt_version = Column(String(100))
    toolchain_version = Column(String(100))
    input_hash = Column(String(64))
    output_hash = Column(String(64))
    execution_time_ms = Column(Integer)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    session = relationship("GradingSession", back_populates="ai_action_logs")

    def __repr__(self):
        return f"<AIActionLog(id={self.id}, action_type='{self.action_type}')>"

    @property
    def execution_time_seconds(self):
        """Get execution time in seconds."""
        if self.execution_time_ms is None:
            return None
        return self.execution_time_ms / 1000.0